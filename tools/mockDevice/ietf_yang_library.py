from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
import numpy as np
from bitarray import bitarray


class yc_deviation_ietf_yang_library__modules_state_module_deviation(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module ietf-yang-library - based on the path /modules-state/module/deviation. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: List of YANG deviation module names and revisions
  used by this server to modify the conformance of
  the module associated with this entry.  Note that
  the same module can be used for deviations for
  multiple modules, so the same entry MAY appear
  within multiple 'module' entries.

  The deviation module MUST be present in the 'module'
  list, with the same name and revision values.
  The 'conformance-type' value will be 'implement' for
  the deviation module.
    """
    __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__revision',)

    _yang_name = 'deviation'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        extmethods = kwargs.pop("extmethods", None)
        if extmethods is False:
            self._extmethods = False
        elif extmethods is not None and isinstance(extmethods, dict):
            self._extmethods = extmethods
        elif hasattr(self, "_parent"):
            extmethods = getattr(self._parent, "_extmethods", None)
            self._extmethods = extmethods
        else:
            self._extmethods = False
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode,
                                                            restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                              'length' : [u'1..max']}), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                   defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        self.__revision = YANGDynClass(
            base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                  RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
            yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='union')

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'modules-state', u'module', u'deviation']

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /modules_state/module/deviation/name (yang:yang-identifier)

        YANG Description: The YANG module or submodule name.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /modules_state/module/deviation/name (yang:yang-identifier)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The YANG module or submodule name.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode,
                                                         restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                           'length' : [u'1..max']}), is_leaf=True,
                             yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, is_keyval=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """name must be of a type compatible with yang:yang-identifier""",
                'defined-type'  : "yang:yang-identifier",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': [u'1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='yang:yang-identifier')""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode,
                                                            restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                              'length' : [u'1..max']}), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                   defining_module='ietf-yang-library', yang_type='yang:yang-identifier')

    def _get_revision(self):
        """
        Getter method for revision, mapped from YANG variable /modules_state/module/deviation/revision (union)

        YANG Description: The YANG module or submodule revision date.
    A zero-length string is used if no revision statement
    is present in the YANG module or submodule.
        """
        return self.__revision

    def _set_revision(self, v, load=False):
        """
        Setter method for revision, mapped from YANG variable /modules_state/module/deviation/revision (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_revision is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_revision() directly.

        YANG Description: The YANG module or submodule revision date.
    A zero-length string is used if no revision statement
    is present in the YANG module or submodule.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        try:
            t = YANGDynClass(v, base=[
                RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
                             yang_name="revision", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='union')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """revision must be of a type compatible with union""",
                'defined-type'  : "ietf-yang-library:union",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='union')""",
            })

        self.__revision = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_revision(self):
        self.__revision = YANGDynClass(
            base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                  RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
            yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='union')

    name = property(_get_name)
    revision = property(_get_revision)

    _pyangbind_elements = {'name': name, 'revision': revision,}


class yc_submodule_ietf_yang_library__modules_state_module_submodules_submodule(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module ietf-yang-library - based on the path /modules-state/module/submodules/submodule. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Each entry represents one submodule within the
  parent module.
    """
    __slots__ = (
    '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__revision', '__schema',)

    _yang_name = 'submodule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        extmethods = kwargs.pop("extmethods", None)
        if extmethods is False:
            self._extmethods = False
        elif extmethods is not None and isinstance(extmethods, dict):
            self._extmethods = extmethods
        elif hasattr(self, "_parent"):
            extmethods = getattr(self._parent, "_extmethods", None)
            self._extmethods = extmethods
        else:
            self._extmethods = False
        self.__schema = YANGDynClass(base=unicode, is_leaf=True, yang_name="schema", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                     defining_module='ietf-yang-library', yang_type='inet:uri')
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode,
                                                            restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                              'length' : [u'1..max']}), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                   defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        self.__revision = YANGDynClass(
            base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                  RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
            yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='union')

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'modules-state', u'module', u'submodules', u'submodule']

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /modules_state/module/submodules/submodule/name (yang:yang-identifier)

        YANG Description: The YANG module or submodule name.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /modules_state/module/submodules/submodule/name (yang:yang-identifier)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The YANG module or submodule name.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode,
                                                         restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                           'length' : [u'1..max']}), is_leaf=True,
                             yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, is_keyval=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """name must be of a type compatible with yang:yang-identifier""",
                'defined-type'  : "yang:yang-identifier",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': [u'1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='yang:yang-identifier')""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode,
                                                            restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                              'length' : [u'1..max']}), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                   defining_module='ietf-yang-library', yang_type='yang:yang-identifier')

    def _get_revision(self):
        """
        Getter method for revision, mapped from YANG variable /modules_state/module/submodules/submodule/revision (union)

        YANG Description: The YANG module or submodule revision date.
    A zero-length string is used if no revision statement
    is present in the YANG module or submodule.
        """
        return self.__revision

    def _set_revision(self, v, load=False):
        """
        Setter method for revision, mapped from YANG variable /modules_state/module/submodules/submodule/revision (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_revision is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_revision() directly.

        YANG Description: The YANG module or submodule revision date.
    A zero-length string is used if no revision statement
    is present in the YANG module or submodule.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        try:
            t = YANGDynClass(v, base=[
                RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
                             yang_name="revision", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='union')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """revision must be of a type compatible with union""",
                'defined-type'  : "ietf-yang-library:union",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='union')""",
            })

        self.__revision = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_revision(self):
        self.__revision = YANGDynClass(
            base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                  RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
            yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='union')

    def _get_schema(self):
        """
        Getter method for schema, mapped from YANG variable /modules_state/module/submodules/submodule/schema (inet:uri)

        YANG Description: Contains a URL that represents the YANG schema
    resource for this module or submodule.

    This leaf will only be present if there is a URL
    available for retrieval of the schema for this entry.
        """
        return self.__schema

    def _set_schema(self, v, load=False):
        """
        Setter method for schema, mapped from YANG variable /modules_state/module/submodules/submodule/schema (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_schema is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_schema() directly.

        YANG Description: Contains a URL that represents the YANG schema
    resource for this module or submodule.

    This leaf will only be present if there is a URL
    available for retrieval of the schema for this entry.
        """
        try:
            t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="schema", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='inet:uri')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """schema must be of a type compatible with inet:uri""",
                'defined-type'  : "inet:uri",
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='inet:uri')""",
            })

        self.__schema = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_schema(self):
        self.__schema = YANGDynClass(base=unicode, is_leaf=True, yang_name="schema", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                     defining_module='ietf-yang-library', yang_type='inet:uri')

    name = property(_get_name)
    revision = property(_get_revision)
    schema = property(_get_schema)

    _pyangbind_elements = {'name': name, 'revision': revision, 'schema': schema,}


class yc_submodules_ietf_yang_library__modules_state_module_submodules(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module ietf-yang-library - based on the path /modules-state/module/submodules. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Contains information about all the submodules used
  by the parent module entry
    """
    __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__submodule',)

    _yang_name = 'submodules'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        extmethods = kwargs.pop("extmethods", None)
        if extmethods is False:
            self._extmethods = False
        elif extmethods is not None and isinstance(extmethods, dict):
            self._extmethods = extmethods
        elif hasattr(self, "_parent"):
            extmethods = getattr(self._parent, "_extmethods", None)
            self._extmethods = extmethods
        else:
            self._extmethods = False
        self.__submodule = YANGDynClass(base=YANGListType("name revision",
                                                          yc_submodule_ietf_yang_library__modules_state_module_submodules_submodule,
                                                          yang_name="submodule", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name revision'), is_container='list',
                                        yang_name="submodule", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                        defining_module='ietf-yang-library', yang_type='list')

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'modules-state', u'module', u'submodules']

    def _get_submodule(self):
        """
        Getter method for submodule, mapped from YANG variable /modules_state/module/submodules/submodule (list)

        YANG Description: Each entry represents one submodule within the
    parent module.
        """
        return self.__submodule

    def _set_submodule(self, v, load=False):
        """
        Setter method for submodule, mapped from YANG variable /modules_state/module/submodules/submodule (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_submodule is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_submodule() directly.

        YANG Description: Each entry represents one submodule within the
    parent module.
        """
        try:
            t = YANGDynClass(v, base=YANGListType("name revision",
                                                  yc_submodule_ietf_yang_library__modules_state_module_submodules_submodule,
                                                  yang_name="submodule", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='name revision'), is_container='list',
                             yang_name="submodule", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='list')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """submodule must be of a type compatible with list""",
                'defined-type'  : "list",
                'generated-type': """YANGDynClass(base=YANGListType("name revision",yc_submodule_ietf_yang_library__modules_state_module_submodules_submodule, yang_name="submodule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision'), is_container='list', yang_name="submodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='list')""",
            })

        self.__submodule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_submodule(self):
        self.__submodule = YANGDynClass(base=YANGListType("name revision",
                                                          yc_submodule_ietf_yang_library__modules_state_module_submodules_submodule,
                                                          yang_name="submodule", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name revision'), is_container='list',
                                        yang_name="submodule", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                        defining_module='ietf-yang-library', yang_type='list')

    submodule = property(_get_submodule)

    _pyangbind_elements = {'submodule': submodule,}


class yc_module_ietf_yang_library__modules_state_module(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module ietf-yang-library - based on the path /modules-state/module. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Each entry represents one module currently
  supported by the server.
    """
    __slots__ = (
    '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__revision', '__schema',
    '__namespace', '__feature', '__deviation', '__conformance_type', '__submodules',)

    _yang_name = 'module'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        extmethods = kwargs.pop("extmethods", None)
        if extmethods is False:
            self._extmethods = False
        elif extmethods is not None and isinstance(extmethods, dict):
            self._extmethods = extmethods
        elif hasattr(self, "_parent"):
            extmethods = getattr(self._parent, "_extmethods", None)
            self._extmethods = extmethods
        else:
            self._extmethods = False
        self.__deviation = YANGDynClass(
            base=YANGListType("name revision", yc_deviation_ietf_yang_library__modules_state_module_deviation,
                              yang_name="deviation", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name revision'), is_container='list',
            yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='list')
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode,
                                                            restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                              'length' : [u'1..max']}), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                   defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        self.__submodules = YANGDynClass(base=yc_submodules_ietf_yang_library__modules_state_module_submodules,
                                         is_container='container', yang_name="submodules", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                         defining_module='ietf-yang-library', yang_type='container')
        self.__conformance_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key",
                                                                        restriction_arg={u'import'   : {},
                                                                                         u'implement': {}}, ),
                                               is_leaf=True, yang_name="conformance-type", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True,
                                               namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                               defining_module='ietf-yang-library', yang_type='enumeration')
        self.__namespace = YANGDynClass(base=unicode, is_leaf=True, yang_name="namespace", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                        defining_module='ietf-yang-library', yang_type='inet:uri')
        self.__feature = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode,
                                                                                          restriction_dict={
                                                                                              'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                                              'length' : [u'1..max']})),
                                      is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                      defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        self.__revision = YANGDynClass(
            base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                  RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
            yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='union')
        self.__schema = YANGDynClass(base=unicode, is_leaf=True, yang_name="schema", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                     defining_module='ietf-yang-library', yang_type='inet:uri')

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'modules-state', u'module']

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /modules_state/module/name (yang:yang-identifier)

        YANG Description: The YANG module or submodule name.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /modules_state/module/name (yang:yang-identifier)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The YANG module or submodule name.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode,
                                                         restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                           'length' : [u'1..max']}), is_leaf=True,
                             yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, is_keyval=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """name must be of a type compatible with yang:yang-identifier""",
                'defined-type'  : "yang:yang-identifier",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': [u'1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='yang:yang-identifier')""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode,
                                                            restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                              'length' : [u'1..max']}), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                   defining_module='ietf-yang-library', yang_type='yang:yang-identifier')

    def _get_revision(self):
        """
        Getter method for revision, mapped from YANG variable /modules_state/module/revision (union)

        YANG Description: The YANG module or submodule revision date.
    A zero-length string is used if no revision statement
    is present in the YANG module or submodule.
        """
        return self.__revision

    def _set_revision(self, v, load=False):
        """
        Setter method for revision, mapped from YANG variable /modules_state/module/revision (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_revision is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_revision() directly.

        YANG Description: The YANG module or submodule revision date.
    A zero-length string is used if no revision statement
    is present in the YANG module or submodule.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        try:
            t = YANGDynClass(v, base=[
                RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
                             yang_name="revision", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='union')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """revision must be of a type compatible with union""",
                'defined-type'  : "ietf-yang-library:union",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='union')""",
            })

        self.__revision = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_revision(self):
        self.__revision = YANGDynClass(
            base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'\\d{4}-\\d{2}-\\d{2}'}),
                  RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'0']}), ], is_leaf=True,
            yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='union')

    def _get_schema(self):
        """
        Getter method for schema, mapped from YANG variable /modules_state/module/schema (inet:uri)

        YANG Description: Contains a URL that represents the YANG schema
    resource for this module or submodule.

    This leaf will only be present if there is a URL
    available for retrieval of the schema for this entry.
        """
        return self.__schema

    def _set_schema(self, v, load=False):
        """
        Setter method for schema, mapped from YANG variable /modules_state/module/schema (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_schema is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_schema() directly.

        YANG Description: Contains a URL that represents the YANG schema
    resource for this module or submodule.

    This leaf will only be present if there is a URL
    available for retrieval of the schema for this entry.
        """
        try:
            t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="schema", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='inet:uri')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """schema must be of a type compatible with inet:uri""",
                'defined-type'  : "inet:uri",
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='inet:uri')""",
            })

        self.__schema = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_schema(self):
        self.__schema = YANGDynClass(base=unicode, is_leaf=True, yang_name="schema", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                     defining_module='ietf-yang-library', yang_type='inet:uri')

    def _get_namespace(self):
        """
        Getter method for namespace, mapped from YANG variable /modules_state/module/namespace (inet:uri)

        YANG Description: The XML namespace identifier for this module.
        """
        return self.__namespace

    def _set_namespace(self, v, load=False):
        """
        Setter method for namespace, mapped from YANG variable /modules_state/module/namespace (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_namespace is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_namespace() directly.

        YANG Description: The XML namespace identifier for this module.
        """
        try:
            t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="namespace", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='inet:uri')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """namespace must be of a type compatible with inet:uri""",
                'defined-type'  : "inet:uri",
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='inet:uri')""",
            })

        self.__namespace = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_namespace(self):
        self.__namespace = YANGDynClass(base=unicode, is_leaf=True, yang_name="namespace", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                        defining_module='ietf-yang-library', yang_type='inet:uri')

    def _get_feature(self):
        """
        Getter method for feature, mapped from YANG variable /modules_state/module/feature (yang:yang-identifier)

        YANG Description: List of YANG feature names from this module that are
    supported by the server, regardless whether they are
    defined in the module or any included submodule.
        """
        return self.__feature

    def _set_feature(self, v, load=False):
        """
        Setter method for feature, mapped from YANG variable /modules_state/module/feature (yang:yang-identifier)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_feature is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_feature() directly.

        YANG Description: List of YANG feature names from this module that are
    supported by the server, regardless whether they are
    defined in the module or any included submodule.
        """
        try:
            t = YANGDynClass(v, base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode,
                                                                                    restriction_dict={
                                                                                        'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                                        'length' : [u'1..max']})),
                             is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='yang:yang-identifier')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """feature must be of a type compatible with yang:yang-identifier""",
                'defined-type'  : "yang:yang-identifier",
                'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': [u'1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='yang:yang-identifier')""",
            })

        self.__feature = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_feature(self):
        self.__feature = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode,
                                                                                          restriction_dict={
                                                                                              'pattern': u'[a-zA-Z_][a-zA-Z0-9\\-_.]*',
                                                                                              'length' : [u'1..max']})),
                                      is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                      defining_module='ietf-yang-library', yang_type='yang:yang-identifier')

    def _get_deviation(self):
        """
        Getter method for deviation, mapped from YANG variable /modules_state/module/deviation (list)

        YANG Description: List of YANG deviation module names and revisions
    used by this server to modify the conformance of
    the module associated with this entry.  Note that
    the same module can be used for deviations for
    multiple modules, so the same entry MAY appear
    within multiple 'module' entries.

    The deviation module MUST be present in the 'module'
    list, with the same name and revision values.
    The 'conformance-type' value will be 'implement' for
    the deviation module.
        """
        return self.__deviation

    def _set_deviation(self, v, load=False):
        """
        Setter method for deviation, mapped from YANG variable /modules_state/module/deviation (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_deviation is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_deviation() directly.

        YANG Description: List of YANG deviation module names and revisions
    used by this server to modify the conformance of
    the module associated with this entry.  Note that
    the same module can be used for deviations for
    multiple modules, so the same entry MAY appear
    within multiple 'module' entries.

    The deviation module MUST be present in the 'module'
    list, with the same name and revision values.
    The 'conformance-type' value will be 'implement' for
    the deviation module.
        """
        try:
            t = YANGDynClass(v, base=YANGListType("name revision",
                                                  yc_deviation_ietf_yang_library__modules_state_module_deviation,
                                                  yang_name="deviation", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='name revision'), is_container='list',
                             yang_name="deviation", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='list')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """deviation must be of a type compatible with list""",
                'defined-type'  : "list",
                'generated-type': """YANGDynClass(base=YANGListType("name revision",yc_deviation_ietf_yang_library__modules_state_module_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision'), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='list')""",
            })

        self.__deviation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_deviation(self):
        self.__deviation = YANGDynClass(
            base=YANGListType("name revision", yc_deviation_ietf_yang_library__modules_state_module_deviation,
                              yang_name="deviation", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name revision'), is_container='list',
            yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
            defining_module='ietf-yang-library', yang_type='list')

    def _get_conformance_type(self):
        """
        Getter method for conformance_type, mapped from YANG variable /modules_state/module/conformance_type (enumeration)

        YANG Description: Indicates the type of conformance the server is claiming
    for the YANG module identified by this entry.
        """
        return self.__conformance_type

    def _set_conformance_type(self, v, load=False):
        """
        Setter method for conformance_type, mapped from YANG variable /modules_state/module/conformance_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_conformance_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_conformance_type() directly.

        YANG Description: Indicates the type of conformance the server is claiming
    for the YANG module identified by this entry.
        """
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode, restriction_type="dict_key",
                                                         restriction_arg={u'import': {}, u'implement': {}}, ),
                             is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='enumeration')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """conformance_type must be of a type compatible with enumeration""",
                'defined-type'  : "ietf-yang-library:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'import': {}, u'implement': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='enumeration')""",
            })

        self.__conformance_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_conformance_type(self):
        self.__conformance_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key",
                                                                        restriction_arg={u'import'   : {},
                                                                                         u'implement': {}}, ),
                                               is_leaf=True, yang_name="conformance-type", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True,
                                               namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                               defining_module='ietf-yang-library', yang_type='enumeration')

    def _get_submodules(self):
        """
        Getter method for submodules, mapped from YANG variable /modules_state/module/submodules (container)

        YANG Description: Contains information about all the submodules used
    by the parent module entry
        """
        return self.__submodules

    def _set_submodules(self, v, load=False):
        """
        Setter method for submodules, mapped from YANG variable /modules_state/module/submodules (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_submodules is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_submodules() directly.

        YANG Description: Contains information about all the submodules used
    by the parent module entry
        """
        try:
            t = YANGDynClass(v, base=yc_submodules_ietf_yang_library__modules_state_module_submodules,
                             is_container='container', yang_name="submodules", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='container')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """submodules must be of a type compatible with container""",
                'defined-type'  : "container",
                'generated-type': """YANGDynClass(base=yc_submodules_ietf_yang_library__modules_state_module_submodules, is_container='container', yang_name="submodules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='container')""",
            })

        self.__submodules = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_submodules(self):
        self.__submodules = YANGDynClass(base=yc_submodules_ietf_yang_library__modules_state_module_submodules,
                                         is_container='container', yang_name="submodules", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                         defining_module='ietf-yang-library', yang_type='container')

    name = property(_get_name)
    revision = property(_get_revision)
    schema = property(_get_schema)
    namespace = property(_get_namespace)
    feature = property(_get_feature)
    deviation = property(_get_deviation)
    conformance_type = property(_get_conformance_type)
    submodules = property(_get_submodules)

    _pyangbind_elements = {'name'      : name, 'revision': revision, 'schema': schema, 'namespace': namespace,
                           'feature'   : feature, 'deviation': deviation, 'conformance_type': conformance_type,
                           'submodules': submodules,}


class yc_modules_state_ietf_yang_library__modules_state(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module ietf-yang-library - based on the path /modules-state. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Contains YANG module monitoring information.
    """
    __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__module_set_id', '__module',)

    _yang_name = 'modules-state'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        extmethods = kwargs.pop("extmethods", None)
        if extmethods is False:
            self._extmethods = False
        elif extmethods is not None and isinstance(extmethods, dict):
            self._extmethods = extmethods
        elif hasattr(self, "_parent"):
            extmethods = getattr(self._parent, "_extmethods", None)
            self._extmethods = extmethods
        else:
            self._extmethods = False
        self.__module = YANGDynClass(
            base=YANGListType("name revision", yc_module_ietf_yang_library__modules_state_module, yang_name="module",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='name revision'), is_container='list', yang_name="module", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library',
            yang_type='list')
        self.__module_set_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="module-set-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True,
                                            namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                            defining_module='ietf-yang-library', yang_type='string')

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'modules-state']

    def _get_module_set_id(self):
        """
        Getter method for module_set_id, mapped from YANG variable /modules_state/module_set_id (string)

        YANG Description: Contains a server-specific identifier representing
    the current set of modules and submodules.  The
    server MUST change the value of this leaf if the
    information represented by the 'module' list instances
    has changed.
        """
        return self.__module_set_id

    def _set_module_set_id(self, v, load=False):
        """
        Setter method for module_set_id, mapped from YANG variable /modules_state/module_set_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_module_set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_module_set_id() directly.

        YANG Description: Contains a server-specific identifier representing
    the current set of modules and submodules.  The
    server MUST change the value of this leaf if the
    information represented by the 'module' list instances
    has changed.
        """
        try:
            t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="module-set-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='string')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """module_set_id must be of a type compatible with string""",
                'defined-type'  : "string",
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="module-set-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='string')""",
            })

        self.__module_set_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_module_set_id(self):
        self.__module_set_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="module-set-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True,
                                            namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                            defining_module='ietf-yang-library', yang_type='string')

    def _get_module(self):
        """
        Getter method for module, mapped from YANG variable /modules_state/module (list)

        YANG Description: Each entry represents one module currently
    supported by the server.
        """
        return self.__module

    def _set_module(self, v, load=False):
        """
        Setter method for module, mapped from YANG variable /modules_state/module (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_module is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_module() directly.

        YANG Description: Each entry represents one module currently
    supported by the server.
        """
        try:
            t = YANGDynClass(v, base=YANGListType("name revision", yc_module_ietf_yang_library__modules_state_module,
                                                  yang_name="module", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='name revision'), is_container='list', yang_name="module",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='list')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """module must be of a type compatible with list""",
                'defined-type'  : "list",
                'generated-type': """YANGDynClass(base=YANGListType("name revision",yc_module_ietf_yang_library__modules_state_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision'), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='list')""",
            })

        self.__module = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_module(self):
        self.__module = YANGDynClass(
            base=YANGListType("name revision", yc_module_ietf_yang_library__modules_state_module, yang_name="module",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='name revision'), is_container='list', yang_name="module", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library',
            yang_type='list')

    module_set_id = property(_get_module_set_id)
    module = property(_get_module)

    _pyangbind_elements = {'module_set_id': module_set_id, 'module': module,}


class ietf_yang_library(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module ietf-yang-library - based on the path /ietf-yang-library. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: This module contains monitoring information about the YANG
  modules and submodules that are used within a YANG-based
  server.

  Copyright (c) 2016 IETF Trust and the persons identified as
  authors of the code.  All rights reserved.

  Redistribution and use in source and binary forms, with or
  without modification, is permitted pursuant to, and subject
  to the license terms contained in, the Simplified BSD License
  set forth in Section 4.c of the IETF Trust's Legal Provisions
  Relating to IETF Documents
  (http://trustee.ietf.org/license-info).

  This version of this YANG module is part of RFC XXXX; see
  the RFC itself for full legal notices.
    """
    __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__modules_state',)

    _yang_name = 'ietf-yang-library'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        extmethods = kwargs.pop("extmethods", None)
        if extmethods is False:
            self._extmethods = False
        elif extmethods is not None and isinstance(extmethods, dict):
            self._extmethods = extmethods
        elif hasattr(self, "_parent"):
            extmethods = getattr(self._parent, "_extmethods", None)
            self._extmethods = extmethods
        else:
            self._extmethods = False
        self.__modules_state = YANGDynClass(base=yc_modules_state_ietf_yang_library__modules_state,
                                            is_container='container', yang_name="modules-state", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True,
                                            namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                            defining_module='ietf-yang-library', yang_type='container')

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_modules_state(self):
        """
        Getter method for modules_state, mapped from YANG variable /modules_state (container)

        YANG Description: Contains YANG module monitoring information.
        """
        return self.__modules_state

    def _set_modules_state(self, v, load=False):
        """
        Setter method for modules_state, mapped from YANG variable /modules_state (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_modules_state is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_modules_state() directly.

        YANG Description: Contains YANG module monitoring information.
        """
        try:
            t = YANGDynClass(v, base=yc_modules_state_ietf_yang_library__modules_state, is_container='container',
                             yang_name="modules-state", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                             defining_module='ietf-yang-library', yang_type='container')
        except (TypeError, ValueError):
            raise ValueError({
                'error-string'  : """modules_state must be of a type compatible with container""",
                'defined-type'  : "container",
                'generated-type': """YANGDynClass(base=yc_modules_state_ietf_yang_library__modules_state, is_container='container', yang_name="modules-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library', defining_module='ietf-yang-library', yang_type='container')""",
            })

        self.__modules_state = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_modules_state(self):
        self.__modules_state = YANGDynClass(base=yc_modules_state_ietf_yang_library__modules_state,
                                            is_container='container', yang_name="modules-state", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True,
                                            namespace='urn:ietf:params:xml:ns:yang:ietf-yang-library',
                                            defining_module='ietf-yang-library', yang_type='container')

    modules_state = property(_get_modules_state, _set_modules_state)

    _pyangbind_elements = {'modules_state': modules_state,}
