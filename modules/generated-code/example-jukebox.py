
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
import numpy as np
from bitarray import bitarray


class yc_admin_example_jukebox__jukebox_library_artist_album_admin(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/library/artist/album/admin. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative information for the album.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__label', '__catalogue_number',)

  _yang_name = 'admin'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__catalogue_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="catalogue-number", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='http://example.com/ns/example-jukebox',
                                           defining_module='example-jukebox', yang_type='string')
    self.__label = YANGDynClass(base=unicode, is_leaf=True, yang_name="label", parent=self,
                                path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='string')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'library', u'artist', u'album', u'admin']

  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /jukebox/library/artist/album/admin/label (string)

    YANG Description: The label that released the album.
    """
    return self.__label

  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /jukebox/library/artist/album/admin/label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: The label that released the album.
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """label must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=unicode, is_leaf=True, yang_name="label", parent=self,
                                path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='string')

  def _get_catalogue_number(self):
    """
    Getter method for catalogue_number, mapped from YANG variable /jukebox/library/artist/album/admin/catalogue_number (string)

    YANG Description: The album's catalogue number.
    """
    return self.__catalogue_number

  def _set_catalogue_number(self, v, load=False):
    """
    Setter method for catalogue_number, mapped from YANG variable /jukebox/library/artist/album/admin/catalogue_number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_catalogue_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_catalogue_number() directly.

    YANG Description: The album's catalogue number.
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="catalogue-number", parent=self,
                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """catalogue_number must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="catalogue-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__catalogue_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_catalogue_number(self):
    self.__catalogue_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="catalogue-number", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='http://example.com/ns/example-jukebox',
                                           defining_module='example-jukebox', yang_type='string')

  label = property(_get_label, _set_label)
  catalogue_number = property(_get_catalogue_number, _set_catalogue_number)

  _pyangbind_elements = {'label': label, 'catalogue_number': catalogue_number,}


class yc_song_example_jukebox__jukebox_library_artist_album_song(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/library/artist/album/song. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents one song resource within one
album resource, within the jukebox library.
  """
  __slots__ = (
  '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__location', '__format', '__length',)

  _yang_name = 'song'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__length = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="length", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                 yang_type='uint32')
    self.__format = YANGDynClass(base=unicode, is_leaf=True, yang_name="format", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                 yang_type='string')
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                               is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')
    self.__location = YANGDynClass(base=unicode, is_leaf=True, yang_name="location", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                   yang_type='string')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'library', u'artist', u'album', u'song']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /jukebox/library/artist/album/song/name (string)

    YANG Description: The name of the song
    """
    return self.__name

  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /jukebox/library/artist/album/song/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the song
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                           " within an instantiated list")

    try:
      t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                       is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True, is_keyval=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """name must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                               is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')

  def _get_location(self):
    """
    Getter method for location, mapped from YANG variable /jukebox/library/artist/album/song/location (string)

    YANG Description: The file location string of the
media file for the song
    """
    return self.__location

  def _set_location(self, v, load=False):
    """
    Setter method for location, mapped from YANG variable /jukebox/library/artist/album/song/location (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_location is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_location() directly.

    YANG Description: The file location string of the
media file for the song
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """location must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__location = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_location(self):
    self.__location = YANGDynClass(base=unicode, is_leaf=True, yang_name="location", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                   yang_type='string')

  def _get_format(self):
    """
    Getter method for format, mapped from YANG variable /jukebox/library/artist/album/song/format (string)

    YANG Description: An identifier string for the media type
for the file associated with the
'location' leaf for this entry.
    """
    return self.__format

  def _set_format(self, v, load=False):
    """
    Setter method for format, mapped from YANG variable /jukebox/library/artist/album/song/format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_format() directly.

    YANG Description: An identifier string for the media type
for the file associated with the
'location' leaf for this entry.
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """format must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_format(self):
    self.__format = YANGDynClass(base=unicode, is_leaf=True, yang_name="format", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                 yang_type='string')

  def _get_length(self):
    """
    Getter method for length, mapped from YANG variable /jukebox/library/artist/album/song/length (uint32)

    YANG Description: The duration of this song in seconds.
    """
    return self.__length

  def _set_length(self, v, load=False):
    """
    Setter method for length, mapped from YANG variable /jukebox/library/artist/album/song/length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_length() directly.

    YANG Description: The duration of this song in seconds.
    """
    try:
      t = YANGDynClass(v, base=np.uint32, is_leaf=True, yang_name="length", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """length must be of a type compatible with uint32""",
        'defined-type': "uint32",
        'generated-type': """YANGDynClass(base=np.uint32, is_leaf=True, yang_name="length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint32')""",
      })

    self.__length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_length(self):
    self.__length = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="length", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                 yang_type='uint32')

  name = property(_get_name, _set_name)
  location = property(_get_location, _set_location)
  format = property(_get_format, _set_format)
  length = property(_get_length, _set_length)

  _pyangbind_elements = {'name': name, 'location': location, 'format': format, 'length': length,}


class yc_album_example_jukebox__jukebox_library_artist_album(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/library/artist/album. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents one album resource within one
artist resource, within the jukebox library.
  """
  __slots__ = (
  '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__genre', '__year', '__admin',
  '__song',)

  _yang_name = 'album'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__genre = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key",
                                                         restriction_arg={u'blues': {'@module': u'example-jukebox',
                                                                                     '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:rock': {'@module': u'example-jukebox',
                                                                                         '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:pop': {'@module': u'example-jukebox',
                                                                                        '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'country': {'@module': u'example-jukebox',
                                                                                       '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jazz': {'@module': u'example-jukebox',
                                                                                    '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'pop': {'@module': u'example-jukebox',
                                                                                   '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:jazz': {'@module': u'example-jukebox',
                                                                                         '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:country': {
                                                                            '@module': u'example-jukebox',
                                                                            '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'rock': {'@module': u'example-jukebox',
                                                                                    '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:alternative': {
                                                                            '@module': u'example-jukebox',
                                                                            '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'alternative': {
                                                                            '@module': u'example-jukebox',
                                                                            '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:blues': {'@module': u'example-jukebox',
                                                                                          '@namespace': u'http://example.com/ns/example-jukebox'}}, ),
                                is_leaf=True, yang_name="genre", parent=self, path_helper=self._path_helper,
                                extmethods=self._extmethods, register_paths=True,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='identityref')
    self.__admin = YANGDynClass(base=yc_admin_example_jukebox__jukebox_library_artist_album_admin,
                                is_container='container', yang_name="admin", parent=self, path_helper=self._path_helper,
                                extmethods=self._extmethods, register_paths=True,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='container')
    self.__song = YANGDynClass(
      base=YANGListType("name", yc_song_example_jukebox__jukebox_library_artist_album_song, yang_name="song",
                        parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                        yang_keys='name'), is_container='list', yang_name="song", parent=self,
      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
      namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                               is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')
    self.__year = YANGDynClass(
      base=RestrictedClassType(base_type=np.uint16, restriction_dict={'range': [u'1900 .. max']}), is_leaf=True,
      yang_name="year", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
      namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint16')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'library', u'artist', u'album']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /jukebox/library/artist/album/name (string)

    YANG Description: The name of the album.
    """
    return self.__name

  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /jukebox/library/artist/album/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the album.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                           " within an instantiated list")

    try:
      t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                       is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True, is_keyval=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """name must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                               is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')

  def _get_genre(self):
    """
    Getter method for genre, mapped from YANG variable /jukebox/library/artist/album/genre (identityref)

    YANG Description: The genre identifying the type of music on
the album.
    """
    return self.__genre

  def _set_genre(self, v, load=False):
    """
    Setter method for genre, mapped from YANG variable /jukebox/library/artist/album/genre (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_genre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_genre() directly.

    YANG Description: The genre identifying the type of music on
the album.
    """
    try:
      t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={
        u'blues': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jbox:rock': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jbox:pop': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'country': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jazz': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'pop': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jbox:jazz': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jbox:country': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'rock': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jbox:alternative': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'alternative': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'},
        u'jbox:blues': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}}, ),
                       is_leaf=True, yang_name="genre", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='identityref')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """genre must be of a type compatible with identityref""",
        'defined-type': "example-jukebox:identityref",
        'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'blues': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jbox:rock': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jbox:pop': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'country': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jazz': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'pop': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jbox:jazz': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jbox:country': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'rock': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jbox:alternative': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'alternative': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}, u'jbox:blues': {'@module': u'example-jukebox', '@namespace': u'http://example.com/ns/example-jukebox'}},), is_leaf=True, yang_name="genre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='identityref')""",
      })

    self.__genre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_genre(self):
    self.__genre = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key",
                                                         restriction_arg={u'blues': {'@module': u'example-jukebox',
                                                                                     '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:rock': {'@module': u'example-jukebox',
                                                                                         '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:pop': {'@module': u'example-jukebox',
                                                                                        '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'country': {'@module': u'example-jukebox',
                                                                                       '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jazz': {'@module': u'example-jukebox',
                                                                                    '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'pop': {'@module': u'example-jukebox',
                                                                                   '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:jazz': {'@module': u'example-jukebox',
                                                                                         '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:country': {
                                                                            '@module': u'example-jukebox',
                                                                            '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'rock': {'@module': u'example-jukebox',
                                                                                    '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:alternative': {
                                                                            '@module': u'example-jukebox',
                                                                            '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'alternative': {
                                                                            '@module': u'example-jukebox',
                                                                            '@namespace': u'http://example.com/ns/example-jukebox'},
                                                                          u'jbox:blues': {'@module': u'example-jukebox',
                                                                                          '@namespace': u'http://example.com/ns/example-jukebox'}}, ),
                                is_leaf=True, yang_name="genre", parent=self, path_helper=self._path_helper,
                                extmethods=self._extmethods, register_paths=True,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='identityref')

  def _get_year(self):
    """
    Getter method for year, mapped from YANG variable /jukebox/library/artist/album/year (uint16)

    YANG Description: The year the album was released
    """
    return self.__year

  def _set_year(self, v, load=False):
    """
    Setter method for year, mapped from YANG variable /jukebox/library/artist/album/year (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_year is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_year() directly.

    YANG Description: The year the album was released
    """
    try:
      t = YANGDynClass(v, base=RestrictedClassType(base_type=np.uint16, restriction_dict={'range': [u'1900 .. max']}),
                       is_leaf=True, yang_name="year", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint16')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """year must be of a type compatible with uint16""",
        'defined-type': "uint16",
        'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=np.uint16, restriction_dict={'range': [u'1900 .. max']}), is_leaf=True, yang_name="year", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint16')""",
      })

    self.__year = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_year(self):
    self.__year = YANGDynClass(
      base=RestrictedClassType(base_type=np.uint16, restriction_dict={'range': [u'1900 .. max']}), is_leaf=True,
      yang_name="year", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
      namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint16')

  def _get_admin(self):
    """
    Getter method for admin, mapped from YANG variable /jukebox/library/artist/album/admin (container)

    YANG Description: Administrative information for the album.
    """
    return self.__admin

  def _set_admin(self, v, load=False):
    """
    Setter method for admin, mapped from YANG variable /jukebox/library/artist/album/admin (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin() directly.

    YANG Description: Administrative information for the album.
    """
    try:
      t = YANGDynClass(v, base=yc_admin_example_jukebox__jukebox_library_artist_album_admin, is_container='container',
                       yang_name="admin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='container')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """admin must be of a type compatible with container""",
        'defined-type': "container",
        'generated-type': """YANGDynClass(base=yc_admin_example_jukebox__jukebox_library_artist_album_admin, is_container='container', yang_name="admin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='container')""",
      })

    self.__admin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin(self):
    self.__admin = YANGDynClass(base=yc_admin_example_jukebox__jukebox_library_artist_album_admin,
                                is_container='container', yang_name="admin", parent=self, path_helper=self._path_helper,
                                extmethods=self._extmethods, register_paths=True,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='container')

  def _get_song(self):
    """
    Getter method for song, mapped from YANG variable /jukebox/library/artist/album/song (list)

    YANG Description: Represents one song resource within one
album resource, within the jukebox library.
    """
    return self.__song

  def _set_song(self, v, load=False):
    """
    Setter method for song, mapped from YANG variable /jukebox/library/artist/album/song (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_song is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_song() directly.

    YANG Description: Represents one song resource within one
album resource, within the jukebox library.
    """
    try:
      t = YANGDynClass(v, base=YANGListType("name", yc_song_example_jukebox__jukebox_library_artist_album_song,
                                            yang_name="song", parent=self, is_container='list', user_ordered=False,
                                            path_helper=self._path_helper, yang_keys='name'), is_container='list',
                       yang_name="song", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='list')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """song must be of a type compatible with list""",
        'defined-type': "list",
        'generated-type': """YANGDynClass(base=YANGListType("name",yc_song_example_jukebox__jukebox_library_artist_album_song, yang_name="song", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="song", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')""",
      })

    self.__song = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_song(self):
    self.__song = YANGDynClass(
      base=YANGListType("name", yc_song_example_jukebox__jukebox_library_artist_album_song, yang_name="song",
                        parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                        yang_keys='name'), is_container='list', yang_name="song", parent=self,
      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
      namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')

  name = property(_get_name, _set_name)
  genre = property(_get_genre, _set_genre)
  year = property(_get_year, _set_year)
  admin = property(_get_admin, _set_admin)
  song = property(_get_song, _set_song)

  _pyangbind_elements = {'name': name, 'genre': genre, 'year': year, 'admin': admin, 'song': song,}


class yc_artist_example_jukebox__jukebox_library_artist(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/library/artist. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents one artist resource within the
jukebox library resource.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__album',)

  _yang_name = 'artist'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__album = YANGDynClass(
      base=YANGListType("name", yc_album_example_jukebox__jukebox_library_artist_album, yang_name="album", parent=self,
                        is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'),
      is_container='list', yang_name="album", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
      register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
      yang_type='list')
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                               is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'library', u'artist']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /jukebox/library/artist/name (string)

    YANG Description: The name of the artist.
    """
    return self.__name

  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /jukebox/library/artist/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the artist.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                           " within an instantiated list")

    try:
      t = YANGDynClass(v, base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                       is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True, is_keyval=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """name must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1 .. max']}),
                               is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')

  def _get_album(self):
    """
    Getter method for album, mapped from YANG variable /jukebox/library/artist/album (list)

    YANG Description: Represents one album resource within one
artist resource, within the jukebox library.
    """
    return self.__album

  def _set_album(self, v, load=False):
    """
    Setter method for album, mapped from YANG variable /jukebox/library/artist/album (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_album is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_album() directly.

    YANG Description: Represents one album resource within one
artist resource, within the jukebox library.
    """
    try:
      t = YANGDynClass(v, base=YANGListType("name", yc_album_example_jukebox__jukebox_library_artist_album,
                                            yang_name="album", parent=self, is_container='list', user_ordered=False,
                                            path_helper=self._path_helper, yang_keys='name'), is_container='list',
                       yang_name="album", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='list')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """album must be of a type compatible with list""",
        'defined-type': "list",
        'generated-type': """YANGDynClass(base=YANGListType("name",yc_album_example_jukebox__jukebox_library_artist_album, yang_name="album", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="album", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')""",
      })

    self.__album = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_album(self):
    self.__album = YANGDynClass(
      base=YANGListType("name", yc_album_example_jukebox__jukebox_library_artist_album, yang_name="album", parent=self,
                        is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'),
      is_container='list', yang_name="album", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
      register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
      yang_type='list')

  name = property(_get_name, _set_name)
  album = property(_get_album, _set_album)

  _pyangbind_elements = {'name': name, 'album': album,}


class yc_library_example_jukebox__jukebox_library(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/library. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents the jukebox library resource.
  """
  __slots__ = (
  '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__artist', '__artist_count', '__album_count',
  '__song_count',)

  _yang_name = 'library'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__song_count = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="song-count", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='http://example.com/ns/example-jukebox',
                                     defining_module='example-jukebox', yang_type='uint32')
    self.__artist_count = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="artist-count", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='http://example.com/ns/example-jukebox',
                                       defining_module='example-jukebox', yang_type='uint32')
    self.__album_count = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="album-count", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='http://example.com/ns/example-jukebox',
                                      defining_module='example-jukebox', yang_type='uint32')
    self.__artist = YANGDynClass(
      base=YANGListType("name", yc_artist_example_jukebox__jukebox_library_artist, yang_name="artist", parent=self,
                        is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'),
      is_container='list', yang_name="artist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
      register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
      yang_type='list')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'library']

  def _get_artist(self):
    """
    Getter method for artist, mapped from YANG variable /jukebox/library/artist (list)

    YANG Description: Represents one artist resource within the
jukebox library resource.
    """
    return self.__artist

  def _set_artist(self, v, load=False):
    """
    Setter method for artist, mapped from YANG variable /jukebox/library/artist (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_artist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_artist() directly.

    YANG Description: Represents one artist resource within the
jukebox library resource.
    """
    try:
      t = YANGDynClass(v,
                       base=YANGListType("name", yc_artist_example_jukebox__jukebox_library_artist, yang_name="artist",
                                         parent=self, is_container='list', user_ordered=False,
                                         path_helper=self._path_helper, yang_keys='name'), is_container='list',
                       yang_name="artist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='list')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """artist must be of a type compatible with list""",
        'defined-type': "list",
        'generated-type': """YANGDynClass(base=YANGListType("name",yc_artist_example_jukebox__jukebox_library_artist, yang_name="artist", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="artist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')""",
      })

    self.__artist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_artist(self):
    self.__artist = YANGDynClass(
      base=YANGListType("name", yc_artist_example_jukebox__jukebox_library_artist, yang_name="artist", parent=self,
                        is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'),
      is_container='list', yang_name="artist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
      register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
      yang_type='list')

  def _get_artist_count(self):
    """
    Getter method for artist_count, mapped from YANG variable /jukebox/library/artist_count (uint32)

    YANG Description: Number of artists in the library
    """
    return self.__artist_count

  def _set_artist_count(self, v, load=False):
    """
    Setter method for artist_count, mapped from YANG variable /jukebox/library/artist_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_artist_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_artist_count() directly.

    YANG Description: Number of artists in the library
    """
    try:
      t = YANGDynClass(v, base=np.uint32, is_leaf=True, yang_name="artist-count", parent=self,
                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """artist_count must be of a type compatible with uint32""",
        'defined-type': "uint32",
        'generated-type': """YANGDynClass(base=np.uint32, is_leaf=True, yang_name="artist-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint32')""",
      })

    self.__artist_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_artist_count(self):
    self.__artist_count = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="artist-count", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='http://example.com/ns/example-jukebox',
                                       defining_module='example-jukebox', yang_type='uint32')

  def _get_album_count(self):
    """
    Getter method for album_count, mapped from YANG variable /jukebox/library/album_count (uint32)

    YANG Description: Number of albums in the library
    """
    return self.__album_count

  def _set_album_count(self, v, load=False):
    """
    Setter method for album_count, mapped from YANG variable /jukebox/library/album_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_album_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_album_count() directly.

    YANG Description: Number of albums in the library
    """
    try:
      t = YANGDynClass(v, base=np.uint32, is_leaf=True, yang_name="album-count", parent=self,
                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """album_count must be of a type compatible with uint32""",
        'defined-type': "uint32",
        'generated-type': """YANGDynClass(base=np.uint32, is_leaf=True, yang_name="album-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint32')""",
      })

    self.__album_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_album_count(self):
    self.__album_count = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="album-count", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='http://example.com/ns/example-jukebox',
                                      defining_module='example-jukebox', yang_type='uint32')

  def _get_song_count(self):
    """
    Getter method for song_count, mapped from YANG variable /jukebox/library/song_count (uint32)

    YANG Description: Number of songs in the library
    """
    return self.__song_count

  def _set_song_count(self, v, load=False):
    """
    Setter method for song_count, mapped from YANG variable /jukebox/library/song_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_song_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_song_count() directly.

    YANG Description: Number of songs in the library
    """
    try:
      t = YANGDynClass(v, base=np.uint32, is_leaf=True, yang_name="song-count", parent=self,
                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """song_count must be of a type compatible with uint32""",
        'defined-type': "uint32",
        'generated-type': """YANGDynClass(base=np.uint32, is_leaf=True, yang_name="song-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint32')""",
      })

    self.__song_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_song_count(self):
    self.__song_count = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="song-count", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='http://example.com/ns/example-jukebox',
                                     defining_module='example-jukebox', yang_type='uint32')

  artist = property(_get_artist, _set_artist)
  artist_count = property(_get_artist_count)
  album_count = property(_get_album_count)
  song_count = property(_get_song_count)

  _pyangbind_elements = {'artist': artist, 'artist_count': artist_count, 'album_count': album_count,
                         'song_count': song_count,}


class yc_song_example_jukebox__jukebox_playlist_song(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/playlist/song. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Example nested configuration data resource
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index', '__id',)

  _yang_name = 'song'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__index = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="index", parent=self,
                                path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                is_keyval=True, namespace='http://example.com/ns/example-jukebox',
                                defining_module='example-jukebox', yang_type='uint32')
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                             yang_type='leafref')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'playlist', u'song']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /jukebox/playlist/song/index (uint32)

    YANG Description: An arbitrary integer index for this playlist song.
    """
    return self.__index

  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /jukebox/playlist/song/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: An arbitrary integer index for this playlist song.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                           " within an instantiated list")

    try:
      t = YANGDynClass(v, base=np.uint32, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True, is_keyval=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """index must be of a type compatible with uint32""",
        'defined-type': "uint32",
        'generated-type': """YANGDynClass(base=np.uint32, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint32')""",
      })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="index", parent=self,
                                path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                is_keyval=True, namespace='http://example.com/ns/example-jukebox',
                                defining_module='example-jukebox', yang_type='uint32')

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /jukebox/playlist/song/id (leafref)

    YANG Description: Song identifier. Must identify an instance of
/jukebox/library/artist/album/song/name.
    """
    return self.__id

  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /jukebox/playlist/song/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Song identifier. Must identify an instance of
/jukebox/library/artist/album/song/name.
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='leafref')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """id must be of a type compatible with leafref""",
        'defined-type': "leafref",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='leafref')""",
      })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                             yang_type='leafref')

  index = property(_get_index, _set_index)
  id = property(_get_id, _set_id)

  _pyangbind_elements = {'index': index, 'id': id,}


class yc_playlist_example_jukebox__jukebox_playlist(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/playlist. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Example configuration data resource
  """
  __slots__ = (
  '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name', '__description', '__song',)

  _yang_name = 'playlist'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__song = YANGDynClass(
      base=YANGListType("index", yc_song_example_jukebox__jukebox_playlist_song, yang_name="song", parent=self,
                        is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='index'),
      is_container='list', yang_name="song", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
      register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
      yang_type='list')
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='http://example.com/ns/example-jukebox',
                                      defining_module='example-jukebox', yang_type='string')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'playlist']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /jukebox/playlist/name (string)

    YANG Description: The name of the playlist.
    """
    return self.__name

  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /jukebox/playlist/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the playlist.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                           " within an instantiated list")

    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True, is_keyval=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """name must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper,
                               extmethods=self._extmethods, register_paths=True, is_keyval=True,
                               namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                               yang_type='string')

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /jukebox/playlist/description (string)

    YANG Description: A comment describing the playlist.
    """
    return self.__description

  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /jukebox/playlist/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A comment describing the playlist.
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="description", parent=self,
                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """description must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='http://example.com/ns/example-jukebox',
                                      defining_module='example-jukebox', yang_type='string')

  def _get_song(self):
    """
    Getter method for song, mapped from YANG variable /jukebox/playlist/song (list)

    YANG Description: Example nested configuration data resource
    """
    return self.__song

  def _set_song(self, v, load=False):
    """
    Setter method for song, mapped from YANG variable /jukebox/playlist/song (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_song is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_song() directly.

    YANG Description: Example nested configuration data resource
    """
    try:
      t = YANGDynClass(v, base=YANGListType("index", yc_song_example_jukebox__jukebox_playlist_song, yang_name="song",
                                            parent=self, is_container='list', user_ordered=True,
                                            path_helper=self._path_helper, yang_keys='index'), is_container='list',
                       yang_name="song", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='list')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """song must be of a type compatible with list""",
        'defined-type': "list",
        'generated-type': """YANGDynClass(base=YANGListType("index",yc_song_example_jukebox__jukebox_playlist_song, yang_name="song", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='index'), is_container='list', yang_name="song", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')""",
      })

    self.__song = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_song(self):
    self.__song = YANGDynClass(
      base=YANGListType("index", yc_song_example_jukebox__jukebox_playlist_song, yang_name="song", parent=self,
                        is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='index'),
      is_container='list', yang_name="song", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
      register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
      yang_type='list')

  name = property(_get_name, _set_name)
  description = property(_get_description, _set_description)
  song = property(_get_song, _set_song)

  _pyangbind_elements = {'name': name, 'description': description, 'song': song,}


class yc_player_example_jukebox__jukebox_player(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox/player. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents the jukebox player resource.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__gap',)

  _yang_name = 'player'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__gap = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0.0 .. 2.0']}),
                              is_leaf=True, yang_name="gap", parent=self, path_helper=self._path_helper,
                              extmethods=self._extmethods, register_paths=True,
                              namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                              yang_type='decimal64')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox', u'player']

  def _get_gap(self):
    """
    Getter method for gap, mapped from YANG variable /jukebox/player/gap (decimal64)

    YANG Description: Time gap between each song
    """
    return self.__gap

  def _set_gap(self, v, load=False):
    """
    Setter method for gap, mapped from YANG variable /jukebox/player/gap (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gap() directly.

    YANG Description: Time gap between each song
    """
    try:
      t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0.0 .. 2.0']}),
                       is_leaf=True, yang_name="gap", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='decimal64')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """gap must be of a type compatible with decimal64""",
        'defined-type': "decimal64",
        'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0.0 .. 2.0']}), is_leaf=True, yang_name="gap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='decimal64')""",
      })

    self.__gap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gap(self):
    self.__gap = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0.0 .. 2.0']}),
                              is_leaf=True, yang_name="gap", parent=self, path_helper=self._path_helper,
                              extmethods=self._extmethods, register_paths=True,
                              namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                              yang_type='decimal64')

  gap = property(_get_gap, _set_gap)

  _pyangbind_elements = {'gap': gap,}


class yc_jukebox_example_jukebox__jukebox(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /jukebox. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents a jukebox resource, with a library, playlists,
and a play operation.
  """
  __slots__ = (
  '_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__library', '__playlist', '__player',)

  _yang_name = 'jukebox'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__player = YANGDynClass(base=yc_player_example_jukebox__jukebox_player, is_container='container',
                                 yang_name="player", parent=self, path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True,
                                 namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                 yang_type='container')
    self.__playlist = YANGDynClass(
      base=YANGListType("name", yc_playlist_example_jukebox__jukebox_playlist, yang_name="playlist", parent=self,
                        is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'),
      is_container='list', yang_name="playlist", parent=self, path_helper=self._path_helper,
      extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox',
      defining_module='example-jukebox', yang_type='list')
    self.__library = YANGDynClass(base=yc_library_example_jukebox__jukebox_library, is_container='container',
                                  yang_name="library", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                  yang_type='container')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'jukebox']

  def _get_library(self):
    """
    Getter method for library, mapped from YANG variable /jukebox/library (container)

    YANG Description: Represents the jukebox library resource.
    """
    return self.__library

  def _set_library(self, v, load=False):
    """
    Setter method for library, mapped from YANG variable /jukebox/library (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_library is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_library() directly.

    YANG Description: Represents the jukebox library resource.
    """
    try:
      t = YANGDynClass(v, base=yc_library_example_jukebox__jukebox_library, is_container='container',
                       yang_name="library", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='container')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """library must be of a type compatible with container""",
        'defined-type': "container",
        'generated-type': """YANGDynClass(base=yc_library_example_jukebox__jukebox_library, is_container='container', yang_name="library", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='container')""",
      })

    self.__library = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_library(self):
    self.__library = YANGDynClass(base=yc_library_example_jukebox__jukebox_library, is_container='container',
                                  yang_name="library", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                  yang_type='container')

  def _get_playlist(self):
    """
    Getter method for playlist, mapped from YANG variable /jukebox/playlist (list)

    YANG Description: Example configuration data resource
    """
    return self.__playlist

  def _set_playlist(self, v, load=False):
    """
    Setter method for playlist, mapped from YANG variable /jukebox/playlist (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_playlist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_playlist() directly.

    YANG Description: Example configuration data resource
    """
    try:
      t = YANGDynClass(v, base=YANGListType("name", yc_playlist_example_jukebox__jukebox_playlist, yang_name="playlist",
                                            parent=self, is_container='list', user_ordered=False,
                                            path_helper=self._path_helper, yang_keys='name'), is_container='list',
                       yang_name="playlist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=True, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='list')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """playlist must be of a type compatible with list""",
        'defined-type': "list",
        'generated-type': """YANGDynClass(base=YANGListType("name",yc_playlist_example_jukebox__jukebox_playlist, yang_name="playlist", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="playlist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='list')""",
      })

    self.__playlist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_playlist(self):
    self.__playlist = YANGDynClass(
      base=YANGListType("name", yc_playlist_example_jukebox__jukebox_playlist, yang_name="playlist", parent=self,
                        is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'),
      is_container='list', yang_name="playlist", parent=self, path_helper=self._path_helper,
      extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox',
      defining_module='example-jukebox', yang_type='list')

  def _get_player(self):
    """
    Getter method for player, mapped from YANG variable /jukebox/player (container)

    YANG Description: Represents the jukebox player resource.
    """
    return self.__player

  def _set_player(self, v, load=False):
    """
    Setter method for player, mapped from YANG variable /jukebox/player (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_player is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_player() directly.

    YANG Description: Represents the jukebox player resource.
    """
    try:
      t = YANGDynClass(v, base=yc_player_example_jukebox__jukebox_player, is_container='container', yang_name="player",
                       parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='container')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """player must be of a type compatible with container""",
        'defined-type': "container",
        'generated-type': """YANGDynClass(base=yc_player_example_jukebox__jukebox_player, is_container='container', yang_name="player", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='container')""",
      })

    self.__player = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_player(self):
    self.__player = YANGDynClass(base=yc_player_example_jukebox__jukebox_player, is_container='container',
                                 yang_name="player", parent=self, path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True,
                                 namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                 yang_type='container')

  library = property(_get_library, _set_library)
  playlist = property(_get_playlist, _set_playlist)
  player = property(_get_player, _set_player)

  _pyangbind_elements = {'library': library, 'playlist': playlist, 'player': player,}


class example_jukebox(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /example-jukebox. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Example Jukebox Data Model Module
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__jukebox',)

  _yang_name = 'example-jukebox'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__jukebox = YANGDynClass(base=yc_jukebox_example_jukebox__jukebox, is_container='container',
                                  yang_name="jukebox", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                  yang_type='container')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return []

  def _get_jukebox(self):
    """
    Getter method for jukebox, mapped from YANG variable /jukebox (container)

    YANG Description: Represents a jukebox resource, with a library, playlists,
and a play operation.
    """
    return self.__jukebox

  def _set_jukebox(self, v, load=False):
    """
    Setter method for jukebox, mapped from YANG variable /jukebox (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_jukebox is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_jukebox() directly.

    YANG Description: Represents a jukebox resource, with a library, playlists,
and a play operation.
    """
    try:
      t = YANGDynClass(v, base=yc_jukebox_example_jukebox__jukebox, is_container='container', yang_name="jukebox",
                       parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='container')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """jukebox must be of a type compatible with container""",
        'defined-type': "container",
        'generated-type': """YANGDynClass(base=yc_jukebox_example_jukebox__jukebox, is_container='container', yang_name="jukebox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='container')""",
      })

    self.__jukebox = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_jukebox(self):
    self.__jukebox = YANGDynClass(base=yc_jukebox_example_jukebox__jukebox, is_container='container',
                                  yang_name="jukebox", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                  yang_type='container')

  jukebox = property(_get_jukebox, _set_jukebox)

  _pyangbind_elements = {'jukebox': jukebox,}


class yc_input_example_jukebox__example_jukebox_rpc_play_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /example_jukebox_rpc/play/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__playlist', '__song_number',)

  _yang_name = 'input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__playlist = YANGDynClass(base=unicode, is_leaf=True, yang_name="playlist", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False,
                                   namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                   yang_type='string')
    self.__song_number = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="song-number", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False,
                                      namespace='http://example.com/ns/example-jukebox',
                                      defining_module='example-jukebox', yang_type='uint32')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'example_jukebox_rpc', u'play', u'input']

  def _get_playlist(self):
    """
    Getter method for playlist, mapped from YANG variable /example_jukebox_rpc/play/input/playlist (string)

    YANG Description: playlist name
    """
    return self.__playlist

  def _set_playlist(self, v, load=False):
    """
    Setter method for playlist, mapped from YANG variable /example_jukebox_rpc/play/input/playlist (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_playlist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_playlist() directly.

    YANG Description: playlist name
    """
    try:
      t = YANGDynClass(v, base=unicode, is_leaf=True, yang_name="playlist", parent=self, path_helper=self._path_helper,
                       extmethods=self._extmethods, register_paths=False,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='string')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """playlist must be of a type compatible with string""",
        'defined-type': "string",
        'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="playlist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='string')""",
      })

    self.__playlist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_playlist(self):
    self.__playlist = YANGDynClass(base=unicode, is_leaf=True, yang_name="playlist", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False,
                                   namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                   yang_type='string')

  def _get_song_number(self):
    """
    Getter method for song_number, mapped from YANG variable /example_jukebox_rpc/play/input/song_number (uint32)

    YANG Description: Song number in playlist to play
    """
    return self.__song_number

  def _set_song_number(self, v, load=False):
    """
    Setter method for song_number, mapped from YANG variable /example_jukebox_rpc/play/input/song_number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_song_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_song_number() directly.

    YANG Description: Song number in playlist to play
    """
    try:
      t = YANGDynClass(v, base=np.uint32, is_leaf=True, yang_name="song-number", parent=self,
                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='uint32')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """song_number must be of a type compatible with uint32""",
        'defined-type': "uint32",
        'generated-type': """YANGDynClass(base=np.uint32, is_leaf=True, yang_name="song-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='uint32')""",
      })

    self.__song_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_song_number(self):
    self.__song_number = YANGDynClass(base=np.uint32, is_leaf=True, yang_name="song-number", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False,
                                      namespace='http://example.com/ns/example-jukebox',
                                      defining_module='example-jukebox', yang_type='uint32')

  playlist = property(_get_playlist, _set_playlist)
  song_number = property(_get_song_number, _set_song_number)

  _pyangbind_elements = {'playlist': playlist, 'song_number': song_number,}


class yc_play_example_jukebox__example_jukebox_rpc_play(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /example_jukebox_rpc/play. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Control function for the jukebox player
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__input',)

  _yang_name = 'play'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_example_jukebox__example_jukebox_rpc_play_input, is_leaf=True,
                                yang_name="input", parent=self, path_helper=self._path_helper,
                                extmethods=self._extmethods, register_paths=False,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='input')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'example_jukebox_rpc', u'play']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /example_jukebox_rpc/play/input (input)
    """
    return self.__input

  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /example_jukebox_rpc/play/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    try:
      t = YANGDynClass(v, base=yc_input_example_jukebox__example_jukebox_rpc_play_input, is_leaf=True,
                       yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                       register_paths=False, namespace='http://example.com/ns/example-jukebox',
                       defining_module='example-jukebox', yang_type='input')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """input must be of a type compatible with input""",
        'defined-type': "example-jukebox:input",
        'generated-type': """YANGDynClass(base=yc_input_example_jukebox__example_jukebox_rpc_play_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='input')""",
      })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_example_jukebox__example_jukebox_rpc_play_input, is_leaf=True,
                                yang_name="input", parent=self, path_helper=self._path_helper,
                                extmethods=self._extmethods, register_paths=False,
                                namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                                yang_type='input')

  input = property(_get_input, _set_input)

  _pyangbind_elements = {'input': input,}


class yc_example_jukebox_example_jukebox__example_jukebox_rpc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module example-jukebox - based on the path /example_jukebox_rpc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Example Jukebox Data Model Module
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__play',)

  _yang_name = 'example-jukebox'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__play = YANGDynClass(base=yc_play_example_jukebox__example_jukebox_rpc_play, is_leaf=True, yang_name="play",
                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                               register_paths=False, namespace='http://example.com/ns/example-jukebox',
                               defining_module='example-jukebox', yang_type='rpc')

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path() + [self._yang_name]
    else:
      return [u'example_jukebox_rpc']

  def _get_play(self):
    """
    Getter method for play, mapped from YANG variable /example_jukebox_rpc/play (rpc)

    YANG Description: Control function for the jukebox player
    """
    return self.__play

  def _set_play(self, v, load=False):
    """
    Setter method for play, mapped from YANG variable /example_jukebox_rpc/play (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_play is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_play() directly.

    YANG Description: Control function for the jukebox player
    """
    try:
      t = YANGDynClass(v, base=yc_play_example_jukebox__example_jukebox_rpc_play, is_leaf=True, yang_name="play",
                       parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False,
                       namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox',
                       yang_type='rpc')
    except (TypeError, ValueError):
      raise ValueError({
        'error-string': """play must be of a type compatible with rpc""",
        'defined-type': "rpc",
        'generated-type': """YANGDynClass(base=yc_play_example_jukebox__example_jukebox_rpc_play, is_leaf=True, yang_name="play", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://example.com/ns/example-jukebox', defining_module='example-jukebox', yang_type='rpc')""",
      })

    self.__play = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_play(self):
    self.__play = YANGDynClass(base=yc_play_example_jukebox__example_jukebox_rpc_play, is_leaf=True, yang_name="play",
                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                               register_paths=False, namespace='http://example.com/ns/example-jukebox',
                               defining_module='example-jukebox', yang_type='rpc')

  play = property(_get_play, _set_play)

  _pyangbind_elements = {'play': play,}
